# CuraEngine调试信息管控系统说明

## 🎯 系统概述

CuraEngine调试信息管控系统提供了分类的调试信息控制，允许开发者：
1. **按功能模块开启/关闭调试信息**
2. **在开发新功能时只显示相关调试信息**
3. **统一管理所有调试输出的格式和级别**

## 📋 调试分类

### 核心算法
- **BEADING_STRATEGY**: BeadingStrategy相关算法
- **SKELETAL_TRAPEZOIDATION**: 骨架梯形化算法
- **WALL_COMPUTATION**: 墙体计算
- **INFILL**: 填充算法
- **SUPPORT**: 支撑算法
- **TREE_SUPPORT**: 树状支撑

### 路径规划
- **PATH_PLANNING**: 路径规划
- **LAYER_PLAN**: 层规划
- **TRAVEL_OPTIMIZATION**: 行程优化
- **SEAM_PLACEMENT**: 接缝放置

### 几何处理
- **GEOMETRY**: 几何计算
- **POLYGON_PROCESSING**: 多边形处理
- **MESH_PROCESSING**: 网格处理
- **SLICING**: 切片

### 设置和配置
- **SETTINGS**: 设置系统
- **ADAPTIVE_LAYERS**: 自适应层高
- **FLOW_COMPENSATION**: 流量补偿（新功能）

### 输出生成
- **GCODE_GENERATION**: G代码生成
- **GCODE_EXPORT**: G代码导出

### 通信和插件
- **COMMUNICATION**: 通信系统
- **PLUGINS**: 插件系统

### 性能和调试
- **PERFORMANCE**: 性能分析
- **MEMORY**: 内存管理
- **PROGRESS**: 进度报告

### 开发和测试
- **DEVELOPMENT**: 开发调试
- **TESTING**: 测试相关

## 🔧 使用方法

### 1. 命令行参数

#### 启用特定分类
```bash
./CuraEngine slice --debug-categories FLOW_COMPENSATION,BEADING_STRATEGY model.stl
```

#### 只启用一个分类（关闭其他所有）
```bash
./CuraEngine slice --debug-only FLOW_COMPENSATION model.stl
```

#### 查看所有可用分类
```bash
./CuraEngine --list-debug-categories
```

### 2. 代码中使用

#### 包含头文件
```cpp
#include "utils/DebugManager.h"
```

#### 分类调试输出
```cpp
// 流量补偿相关调试
CURA_DEBUG(FLOW_COMPENSATION, "计算流量比例: {:.3f}", flow_ratio);

// BeadingStrategy相关调试
CURA_DEBUG(BEADING_STRATEGY, "厚度{:.2f}mm，bead数量{}", thickness, bead_count);

// 条件调试输出
CURA_DEBUG_IF(WALL_COMPUTATION, thickness < min_width, "检测到极小厚度: {:.2f}mm", thickness);
```

#### 非调试信息（始终显示）
```cpp
// 重要用户信息
CURA_INFO("切片完成，用时{:.2f}秒", elapsed_time);

// 警告信息
CURA_WARN("参数{}可能导致打印质量问题", param_name);

// 错误信息
CURA_ERROR("无法读取文件: {}", filename);
```

### 3. 程序化控制

```cpp
auto& debug_mgr = DebugManager::getInstance();

// 启用特定分类
debug_mgr.enableCategory(DebugManager::Category::FLOW_COMPENSATION);

// 只启用一个分类
debug_mgr.enableOnly(DebugManager::Category::BEADING_STRATEGY);

// 启用所有分类
debug_mgr.enableAll();

// 禁用所有分类
debug_mgr.disableAll();

// 检查分类是否启用
if (debug_mgr.isCategoryEnabled(DebugManager::Category::FLOW_COMPENSATION)) {
    // 执行额外的调试逻辑
}
```

## 📝 开发规范

### 1. 日志级别使用规范

#### CURA_DEBUG (分类调试)
- **用途**: 开发和调试过程中的详细信息
- **特点**: 可以按分类开启/关闭
- **示例**: 算法中间结果、参数值、计算过程

```cpp
CURA_DEBUG(BEADING_STRATEGY, "计算beading: 厚度={:.2f}mm, 结果={}", thickness, result);
```

#### CURA_INFO (信息)
- **用途**: 重要的用户信息，始终显示
- **特点**: 不受分类控制
- **示例**: 进度信息、完成状态、配置信息

```cpp
CURA_INFO("切片完成，生成{}层", layer_count);
```

#### CURA_WARN (警告)
- **用途**: 警告信息，始终显示
- **特点**: 不受分类控制
- **示例**: 参数问题、性能警告、兼容性问题

```cpp
CURA_WARN("min_wall_line_width过小，已自动调整");
```

#### CURA_ERROR (错误)
- **用途**: 错误信息，始终显示
- **特点**: 不受分类控制
- **示例**: 文件读取失败、算法错误、系统错误

```cpp
CURA_ERROR("无法打开文件: {}", filename);
```

### 2. 分类选择指南

根据代码所在的模块和功能选择合适的分类：

| 文件/模块 | 推荐分类 |
|-----------|----------|
| BeadingStrategy*.cpp | BEADING_STRATEGY |
| SkeletalTrapezoidation*.cpp | SKELETAL_TRAPEZOIDATION |
| WallToolPaths.cpp | WALL_COMPUTATION |
| LayerPlan*.cpp | LAYER_PLAN |
| infill/*.cpp | INFILL |
| TreeSupport*.cpp | TREE_SUPPORT |
| FlowCompensated*.cpp | FLOW_COMPENSATION |

### 3. 新功能开发流程

#### 步骤1: 确定分类
为新功能选择或创建合适的调试分类。

#### 步骤2: 只启用相关分类
```bash
./CuraEngine slice --debug-only YOUR_CATEGORY model.stl
```

#### 步骤3: 添加调试输出
在关键位置添加分类调试输出：
```cpp
CURA_DEBUG(YOUR_CATEGORY, "功能开始执行");
CURA_DEBUG(YOUR_CATEGORY, "中间结果: {}", intermediate_result);
CURA_DEBUG(YOUR_CATEGORY, "功能执行完成");
```

#### 步骤4: 测试和调试
运行测试，只会看到你的功能相关的调试信息，不会被其他模块的输出干扰。

## 🔄 迁移现有代码

### 自动重构脚本
使用提供的Python脚本自动重构现有代码：

```bash
cd CuraEngine
python3 scripts/refactor_logging.py
```

### 手动重构指南

#### 替换规则
```cpp
// 旧代码 -> 新代码
spdlog::debug(...) -> CURA_DEBUG(CATEGORY, ...)
spdlog::info(...)  -> CURA_INFO(...) 或 CURA_DEBUG(CATEGORY, ...)
spdlog::warn(...)  -> CURA_WARN(...)
spdlog::error(...) -> CURA_ERROR(...)
```

#### 判断是否为调试信息
包含以下内容的通常是调试信息，应该使用`CURA_DEBUG`:
- 算法中间步骤
- 参数值输出
- 计算过程详情
- 内部状态信息

包含以下内容的通常是用户信息，应该使用`CURA_INFO`:
- 进度报告
- 完成状态
- 配置信息
- 统计数据

## 🎯 最佳实践

### 1. 性能考虑
```cpp
// 好的做法：使用宏，在分类未启用时不会执行
CURA_DEBUG(CATEGORY, "复杂计算结果: {}", expensive_calculation());

// 避免：直接调用，即使分类未启用也会执行计算
if (DebugManager::getInstance().isCategoryEnabled(Category::CATEGORY)) {
    spdlog::debug("复杂计算结果: {}", expensive_calculation());
}
```

### 2. 信息分层
```cpp
// 用户关心的信息
CURA_INFO("开始生成墙体");

// 开发者关心的详细信息
CURA_DEBUG(WALL_COMPUTATION, "墙体参数: 线宽={:.2f}mm, 层数={}", line_width, wall_count);
CURA_DEBUG(WALL_COMPUTATION, "生成{}条墙体路径", path_count);

// 完成信息
CURA_INFO("墙体生成完成，用时{:.2f}秒", elapsed_time);
```

### 3. 错误处理
```cpp
// 错误信息始终显示
CURA_ERROR("BeadingStrategy计算失败: {}", error_msg);

// 调试信息帮助定位问题
CURA_DEBUG(BEADING_STRATEGY, "输入参数: 厚度={:.2f}mm, bead数量={}", thickness, bead_count);
```

## 📚 示例

### 完整示例：流量补偿功能
```cpp
#include "utils/DebugManager.h"

void FlowCompensatedBeadingStrategy::compute(coord_t thickness, coord_t bead_count) const
{
    CURA_DEBUG(FLOW_COMPENSATION, "开始计算流量补偿: 厚度={:.2f}mm", INT2MM(thickness));
    
    if (needsFlowCompensation(thickness)) {
        CURA_DEBUG(FLOW_COMPENSATION, "需要流量补偿，使用稳定宽度{:.2f}mm", INT2MM(min_stable_width_));
        
        double flow_ratio = calculateFlowRatio(thickness, min_stable_width_);
        CURA_DEBUG(FLOW_COMPENSATION, "计算流量比例: {:.3f}", flow_ratio);
        
        if (flow_ratio < 0.5) {
            CURA_WARN("流量比例过低({:.3f})，可能影响打印质量", flow_ratio);
        }
        
        CURA_DEBUG(FLOW_COMPENSATION, "流量补偿计算完成");
    } else {
        CURA_DEBUG(FLOW_COMPENSATION, "厚度足够，无需流量补偿");
    }
}
```

### 使用示例
```bash
# 只查看流量补偿相关调试信息
./CuraEngine slice --debug-only FLOW_COMPENSATION model.stl

# 查看流量补偿和BeadingStrategy调试信息
./CuraEngine slice --debug-categories FLOW_COMPENSATION,BEADING_STRATEGY model.stl

# 查看所有可用分类
./CuraEngine --list-debug-categories
```

这样，开发者可以专注于自己正在开发的功能，不会被其他模块的调试信息干扰，大大提高了开发效率和调试体验。
