# 可控温度层厚速度功能

## 概述

可控温度层厚速度功能允许用户根据打印高度动态调整打印温度、层厚和打印速度，实现更精细的打印控制和更好的打印质量。

## 核心功能

### 1. 可变层厚控制

**参数**: `user_layer_height_definition_enable`, `user_layer_height_definition`

#### 实现逻辑

**文件位置**: `CuraEngine/src/FffPolygonGenerator.cpp`

```cpp
void FffPolygonGenerator::processLayerHeightDefinition(SliceDataStorage& storage)
{
    const bool enable = mesh_group_settings.get<bool>("user_layer_height_definition_enable");
    if (!enable) return;

    const std::string definition = mesh_group_settings.get<std::string>("user_layer_height_definition");
    
    // 解析高度-层厚映射
    std::vector<std::pair<double, double>> height_thickness_pairs;
    parseHeightDefinition(definition, height_thickness_pairs);
    
    // 应用到每一层
    for (size_t layer_idx = 0; layer_idx < storage.layers.size(); layer_idx++) {
        SliceLayer& layer = storage.layers[layer_idx];
        coord_t model_z = calculateModelHeight(layer.printZ, storage);
        
        double thickness = interpolateThickness(model_z, height_thickness_pairs);
        layer.thickness = MM2INT(thickness);
    }
}
```

### 2. 可变温度控制

**参数**: `user_temperature_definition_enable`, `user_temperature_definition`

#### 实现逻辑

**文件位置**: `CuraEngine/src/FffGcodeWriter.cpp`

```cpp
void FffGcodeWriter::processTemperatureDefinition(LayerPlan& gcode_layer, size_t extruder_nr)
{
    const bool enable = mesh_group_settings.get<bool>("user_temperature_definition_enable");
    if (!enable) return;

    const std::string definition = mesh_group_settings.get<std::string>("user_temperature_definition");
    
    // 解析高度-温度映射
    std::vector<std::pair<double, double>> height_temperature_pairs;
    parseTemperatureDefinition(definition, height_temperature_pairs);
    
    // 计算当前层的目标温度
    coord_t model_z = calculateModelHeight(gcode_layer.getLayerZ(), storage);
    double target_temp = interpolateTemperature(model_z, height_temperature_pairs);
    
    // 设置温度
    gcode_layer.setExtruderTemperature(extruder_nr, target_temp);
}
```

### 3. 可变速度控制

**参数**: `user_speed_definition_enable`, `user_speed_definition`

#### 实现逻辑

**文件位置**: `CuraEngine/src/FffGcodeWriter.cpp`

```cpp
void FffGcodeWriter::processSpeedDefinition(LayerPlan& gcode_layer)
{
    const bool enable = mesh_group_settings.get<bool>("user_speed_definition_enable");
    if (!enable) return;

    const std::string definition = mesh_group_settings.get<std::string>("user_speed_definition");
    
    // 解析高度-速度映射
    std::vector<std::pair<double, double>> height_speed_pairs;
    parseSpeedDefinition(definition, height_speed_pairs);
    
    // 计算当前层的速度系数
    coord_t model_z = calculateModelHeight(gcode_layer.getLayerZ(), storage);
    double speed_factor = interpolateSpeed(model_z, height_speed_pairs);
    
    // 应用速度系数到所有路径
    gcode_layer.applySpeedFactor(speed_factor);
}
```

## 核心算法

### 1. 高度-参数映射解析

```cpp
void parseHeightDefinition(const std::string& definition, std::vector<std::pair<double, double>>& pairs)
{
    std::istringstream iss(definition);
    std::string segment;
    
    while (std::getline(iss, segment, ';')) {
        size_t comma_pos = segment.find(',');
        if (comma_pos != std::string::npos) {
            try {
                double height = std::stod(segment.substr(0, comma_pos));
                double value = std::stod(segment.substr(comma_pos + 1));
                pairs.emplace_back(height, value);
            } catch (const std::exception& e) {
                spdlog::warn("解析定义失败: {}", segment);
            }
        }
    }
    
    // 按高度排序
    std::sort(pairs.begin(), pairs.end());
}
```

### 2. 线性插值计算

```cpp
double interpolateValue(coord_t model_z, const std::vector<std::pair<double, double>>& pairs)
{
    if (pairs.empty()) return 0.0;
    
    double height_mm = INT2MM(model_z);
    
    // 边界处理
    if (height_mm <= pairs.front().first) return pairs.front().second;
    if (height_mm >= pairs.back().first) return pairs.back().second;
    
    // 线性插值
    for (size_t i = 0; i < pairs.size() - 1; i++) {
        if (height_mm >= pairs[i].first && height_mm <= pairs[i + 1].first) {
            double ratio = (height_mm - pairs[i].first) / (pairs[i + 1].first - pairs[i].first);
            return pairs[i].second + ratio * (pairs[i + 1].second - pairs[i].second);
        }
    }
    
    return pairs.back().second;
}
```

### 3. 模型高度计算

```cpp
coord_t calculateModelHeight(coord_t layer_z, const SliceDataStorage& storage)
{
    // 计算模型实际高度（排除raft影响）
    coord_t model_z = layer_z;
    
    if (storage.raftOutline.size() > 0) {
        // 有raft结构，需要减去raft厚度
        coord_t raft_total_thickness = 0;
        
        // 计算raft总厚度
        const Settings& mesh_group_settings = Application::getInstance().current_slice_->scene.current_mesh_group->settings;
        
        size_t raft_base_layers = mesh_group_settings.get<size_t>("raft_base_layers");
        size_t raft_interface_layers = mesh_group_settings.get<size_t>("raft_interface_layers");
        size_t raft_surface_layers = mesh_group_settings.get<size_t>("raft_surface_layers");
        
        coord_t raft_base_thickness = mesh_group_settings.get<coord_t>("raft_base_thickness");
        coord_t raft_interface_thickness = mesh_group_settings.get<coord_t>("raft_interface_thickness");
        coord_t raft_surface_thickness = mesh_group_settings.get<coord_t>("raft_surface_thickness");
        
        raft_total_thickness = raft_base_layers * raft_base_thickness +
                              raft_interface_layers * raft_interface_thickness +
                              raft_surface_layers * raft_surface_thickness;
        
        model_z = layer_z - raft_total_thickness;
    }
    
    return std::max(model_z, coord_t(0)); // 确保不为负数
}
```

## 高级功能

### 1. 首层保护机制

```cpp
bool isFirstModelLayer(size_t layer_idx, const SliceDataStorage& storage)
{
    // 检查是否为模型的第一层（排除raft）
    if (storage.raftOutline.size() > 0) {
        // 有raft，第一层是raft之后的第一层
        size_t raft_total_layers = calculateRaftTotalLayers(storage);
        return layer_idx == raft_total_layers;
    } else {
        // 无raft，第一层就是layer 0
        return layer_idx == 0;
    }
}
```

### 2. 温度偏差控制

```cpp
void applyTemperatureWithHysteresis(LayerPlan& gcode_layer, size_t extruder_nr, double target_temp)
{
    static double last_temp = 0.0;
    const double hysteresis_threshold = 5.0; // 5度滞后
    
    if (std::abs(target_temp - last_temp) >= hysteresis_threshold) {
        gcode_layer.setExtruderTemperature(extruder_nr, target_temp);
        last_temp = target_temp;
    }
}
```

### 3. 速度显示优化

```cpp
void LayerPlan::applySpeedFactor(double speed_factor)
{
    for (auto& extruder_plan : extruder_plans_) {
        for (auto& path : extruder_plan.paths_) {
            // 应用速度系数
            path.speed_factor *= speed_factor;
            
            // 更新配置中的速度值以正确显示
            if (path.config) {
                GCodePathConfig* mutable_config = const_cast<GCodePathConfig*>(path.config);
                mutable_config->speed = mutable_config->speed * speed_factor;
            }
        }
    }
}
```

## 相关参数

### 层厚控制参数

1. **user_layer_height_definition_enable**
   - 类型: 布尔值
   - 描述: 启用可变层厚功能

2. **user_layer_height_definition**
   - 类型: 字符串
   - 格式: "高度1,层厚1;高度2,层厚2;..."
   - 示例: "0,0.1;5,0.2;10,0.3"

### 温度控制参数

1. **user_temperature_definition_enable**
   - 类型: 布尔值
   - 描述: 启用可变温度功能

2. **user_temperature_definition**
   - 类型: 字符串
   - 格式: "高度1,温度1;高度2,温度2;..."
   - 示例: "0,200;5,210;10,220"

### 速度控制参数

1. **user_speed_definition_enable**
   - 类型: 布尔值
   - 描述: 启用可变速度功能

2. **user_speed_definition**
   - 类型: 字符串
   - 格式: "高度1,速度系数1;高度2,速度系数2;..."
   - 示例: "0,1.0;5,1.2;10,0.8"

## 应用场景

### 1. 渐变打印

通过逐渐改变参数实现渐变效果。

### 2. 结构优化

在不同高度使用不同参数优化结构强度。

### 3. 表面质量控制

在关键区域使用精细参数提高表面质量。

### 4. 打印效率优化

在非关键区域使用快速参数提高效率。

## 技术挑战与解决方案

### 1. Raft影响处理

**挑战**: Raft结构影响高度计算。

**解决方案**: 计算模型实际高度，排除Raft厚度。

### 2. 参数解析错误处理

**挑战**: 用户输入格式错误。

**解决方案**: 完善的错误处理和回退机制。

### 3. 性能优化

**挑战**: 频繁的插值计算影响性能。

**解决方案**: 缓存计算结果，优化算法复杂度。

### 4. 兼容性保证

**挑战**: 与现有功能的兼容性。

**解决方案**: 渐进式应用，保持向后兼容。
