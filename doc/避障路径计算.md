# 避障路径计算

## 概述

避障路径计算是 CuraEngine 路径优化系统中的关键组件，负责在喷嘴移动时避开已打印的结构，防止碰撞和拖拽。

## 核心算法

### 直线距离计算

```cpp
coord_t getDirectDistance(const Point2LL& a, const Point2LL& b) const
{
    return vSize2(a - b);  // 返回距离的平方
}
```

### 避障距离计算

```cpp
coord_t getCombingDistance(const Point2LL& a, const Point2LL& b)
{
    // 1. 检查是否与边界碰撞
    if (!PolygonUtils::polygonCollidesWithLineSegment(*combing_boundary_, a, b)) {
        return getDirectDistance(a, b);
    }
    
    // 2. 路径数量过多时使用静态惩罚因子
    if (paths_.size() > 100) {
        return getDirectDistance(a, b) * 5;
    }
    
    // 3. 构建避障网格
    if (combing_grid_ == nullptr) {
        constexpr coord_t grid_size = 2000;
        combing_grid_ = PolygonUtils::createLocToLineGrid(*combing_boundary_, grid_size);
    }
    
    // 4. 计算避障路径
    CombPath comb_path;
    constexpr coord_t rounding_error = -25;
    constexpr coord_t tiny_travel_threshold = 0;
    constexpr bool fail_on_unavoidable_obstacles = false;
    
    LinePolygonsCrossings::comb(*combing_boundary_, *combing_grid_, a, b, comb_path, 
                               rounding_error, tiny_travel_threshold, fail_on_unavoidable_obstacles);
    
    // 5. 计算总距离
    coord_t sum = 0;
    Point2LL last_point = a;
    for (const Point2LL& point : comb_path) {
        sum += vSize(point - last_point);
        last_point = point;
    }
    return sum * sum;  // 平方距离，便于比较
}
```

## 避障网格系统

### 网格构建

避障系统使用空间网格来加速碰撞检测：

```cpp
// 构建避障网格
constexpr coord_t grid_size = 2000;  // 2mm网格
combing_grid_ = PolygonUtils::createLocToLineGrid(*combing_boundary_, grid_size);
```

### 网格优化

- **网格大小**: 2000微米（2mm），平衡精度和性能
- **缓存机制**: 避障网格被缓存以避免重复计算
- **内存管理**: 使用智能指针管理网格生命周期

## 碰撞检测

### 线段与多边形碰撞检测

```cpp
bool polygonCollidesWithLineSegment(const Shape& polygon, const Point2LL& a, const Point2LL& b)
{
    // 检查线段是否与多边形边界相交
    for (const auto& poly : polygon) {
        if (PolygonUtils::polygonCollidesWithLineSegment(poly, a, b)) {
            return true;
        }
    }
    return false;
}
```

### 快速预检查

在进行复杂的避障计算之前，系统首先进行快速的直线碰撞检测：

1. **直线可行**: 如果直线路径不与边界碰撞，直接使用直线距离
2. **需要避障**: 如果检测到碰撞，启动避障路径计算
3. **性能优化**: 对于大量路径（>100），使用静态惩罚因子

## 避障路径生成

### LinePolygonsCrossings::comb 算法

这是核心的避障路径生成算法：

```cpp
LinePolygonsCrossings::comb(
    *combing_boundary_,           // 避障边界
    *combing_grid_,              // 空间网格
    start_point,                 // 起始点
    end_point,                   // 终点
    comb_path,                   // 输出路径
    rounding_error,              // 舍入误差容忍度
    tiny_travel_threshold,       // 微小移动阈值
    fail_on_unavoidable_obstacles // 是否在无法避障时失败
);
```

### 算法参数

- **rounding_error**: -25微米，用于处理数值精度问题
- **tiny_travel_threshold**: 0，忽略极小的移动
- **fail_on_unavoidable_obstacles**: false，遇到无法避开的障碍时不失败

## 性能优化策略

### 1. 分层优化

```cpp
// 路径数量过多时使用静态惩罚因子
if (paths_.size() > 100) {
    return getDirectDistance(a, b) * 5;
}
```

当路径数量超过100时，系统使用简化的惩罚因子而不是精确的避障计算，以保持性能。

### 2. 网格缓存

```cpp
// 构建避障网格（仅在需要时）
if (combing_grid_ == nullptr) {
    constexpr coord_t grid_size = 2000;
    combing_grid_ = PolygonUtils::createLocToLineGrid(*combing_boundary_, grid_size);
}
```

避障网格被缓存，避免重复构建。

### 3. 平方距离比较

```cpp
return sum * sum;  // 平方距离，便于比较
```

使用平方距离进行比较，避免开方运算的性能开销。

## 边界定义

### combing_boundary 的构成

避障边界通常包括：

1. **已打印的外壁**: 防止与外壁碰撞
2. **填充区域**: 在某些模式下包含填充
3. **支撑结构**: 避开支撑材料
4. **禁止区域**: 用户定义的禁止移动区域

### 边界更新

边界在每层打印过程中动态更新：

```cpp
// 更新避障边界
void updateCombingBoundary(const Shape& new_boundary) {
    combing_boundary_ = &new_boundary;
    combing_grid_.reset();  // 清除缓存的网格
}
```

## 应用场景

### 1. 外壁打印

```cpp
// 外壁避障配置
PathOrderOptimizer<ConstPolygonRef> wall_optimizer(
    start_point,
    seam_config,
    false,  // detect_loops
    &comb_boundary,  // 使用避障边界
    false,  // reverse_direction
    no_order_requirements,
    true,   // group_outer_walls
    disallowed_areas,
    false,  // use_shortest_for_inner_walls
    overhang_areas
);
```

### 2. 填充打印

```cpp
// 填充避障配置
PathOrderOptimizer<ConstPolygonRef> infill_optimizer(
    start_point,
    ZSeamConfig(EZSeamType::SHORTEST),
    true,   // detect_loops
    nullptr, // 填充通常不需要避障
    false,  // reverse_direction
    no_order_requirements,
    false,  // group_outer_walls
    Shape(), // 填充不考虑禁止区域
    false,  // use_shortest_for_inner_walls
    Shape()  // 填充不考虑悬垂区域
);
```

### 3. 支撑打印

```cpp
// 支撑避障配置
PathOrderOptimizer<ConstPolygonRef> support_optimizer(
    start_point,
    ZSeamConfig(EZSeamType::RANDOM),
    false,  // detect_loops
    &model_boundary,  // 避开模型
    false,  // reverse_direction
    no_order_requirements,
    false,  // group_outer_walls
    model_areas,  // 避免在模型上开始
    false,  // use_shortest_for_inner_walls
    Shape()   // 支撑不考虑悬垂区域
);
```

## 调试和监控

### 性能监控

```cpp
void PathOrderOptimizer::optimize(bool precompute_start)
{
    auto start_time = std::chrono::high_resolution_clock::now();

    // 执行优化算法...

    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);

    spdlog::debug("Path optimization took {} ms for {} paths",
                 duration.count(), paths_.size());
}
```

### 路径质量评估

```cpp
double evaluatePathQuality(const std::vector<OrderablePath>& paths)
{
    double total_distance = 0.0;
    Point2LL current_pos = start_point_;

    for (const auto& path : paths) {
        if (!path.converted_->empty()) {
            Point2LL path_start = (*path.converted_)[path.start_vertex_];
            total_distance += vSize(current_pos - path_start);

            if (path.is_closed_) {
                current_pos = path_start;  // 闭合路径回到起点
            } else {
                current_pos = path.start_vertex_ == 0 ?
                    path.converted_->back() : path.converted_->front();
            }
        }
    }

    return total_distance;
}
```

## 未来改进方向

### 1. 动态网格大小

根据模型复杂度动态调整网格大小，平衡精度和性能。

### 2. 多层次避障

实现多层次的避障策略，对不同类型的障碍使用不同的避障算法。

### 3. 机器学习优化

使用机器学习技术预测最优的避障路径，减少计算时间。
