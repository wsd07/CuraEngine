# CuraEngine 路径优化系统深度分析

## 概述

CuraEngine 的路径优化系统是一个复杂的算法框架，主要通过 `PathOrderOptimizer` 类实现。该系统的核心目标是优化打印路径的顺序，最小化喷嘴在不同打印元素之间的移动距离，同时考虑 Z 缝合位置、避障路径规划等多种因素。

## 核心类结构

### 1. PathOrderOptimizer<Path> 模板类

**文件位置**: `CuraEngine/include/PathOrderOptimizer.h`

这是路径优化的核心类，采用模板设计以支持不同类型的路径数据结构。

#### 主要成员变量

```cpp
class PathOrderOptimizer
{
    std::vector<OrderablePath> paths_;                    // 优化后的路径列表
    std::unordered_map<Path, OrderablePath*> vertices_to_paths_; // 路径映射
    Point2LL start_point_;                               // 起始位置
    ZSeamConfig seam_config_;                           // Z缝合配置
    Shape disallowed_area_for_seams;                    // 禁止缝合的区域
    const Shape* combing_boundary_;                     // 避障边界
    bool detect_loops_;                                 // 是否检测闭合回路
    bool reverse_direction_;                            // 是否反向打印
    bool _group_outer_walls;                           // 是否分组外壁
    const std::unordered_multimap<Path, Path>* order_requirements_; // 顺序约束
    bool use_shortest_for_inner_walls_;                // 内壁是否使用最短路径
    Shape overhang_areas_;                             // 悬垂区域
};
```

#### 关键算法参数

1. **snap_radius**: 10微米，用于邻近点检测的网格大小
2. **_coincident_point_distance**: 10微米，判断端点重合的距离阈值
3. **grid_size**: 2000微米（2mm），避障网格大小
4. **max_distance_ignored**: 喷嘴直径，忽略短距离移动的阈值

### 2. PathOrdering<PathType> 结构

**文件位置**: `CuraEngine/include/path_ordering.h`

表示优化后的路径信息：

```cpp
struct PathOrdering
{
    PathType vertices_;                    // 原始顶点数据
    const PointsSet* converted_;          // 转换后的多边形数据
    size_t start_vertex_;                 // 起始顶点索引
    bool is_closed_;                      // 是否闭合路径
    bool backwards_;                      // 是否反向打印
    std::optional<size_t> force_start_index_; // 强制起始点
    ZSeamConfig seam_config_;            // 缝合配置
    bool is_outer_wall;                  // 是否外壁
};
```

## 优化算法详解

### 1. 主优化流程 (optimize函数)

```cpp
void optimize(bool precompute_start = true)
{
    // 1. 数据预处理
    for (auto& path : paths_) {
        path.converted_ = &path.getVertexData();
        vertices_to_paths_.emplace(path.vertices_, &path);
    }
    
    // 2. 闭合回路检测
    if (detect_loops_) {
        for (auto& path : paths_) {
            if (!path.is_closed_) {
                path.is_closed_ = isLoopingPolyline(path);
            }
        }
    }
    
    // 3. 缝合策略设置
    for (auto& path : paths_) {
        if (use_shortest_for_inner_walls_ && !path.is_outer_wall) {
            path.seam_config_ = ZSeamConfig(EZSeamType::SHORTEST);
        }
    }
    
    // 4. 空间索引构建
    SparsePointGridInclusive<size_t> line_bucket_grid(snap_radius);
    
    // 5. 缝合点预计算
    if (precompute_start) {
        for (auto& path : paths_) {
            if (path.seam_config_.type_ == EZSeamType::RANDOM || 
                path.seam_config_.type_ == EZSeamType::USER_SPECIFIED ||
                path.seam_config_.type_ == EZSeamType::SHARPEST_CORNER) {
                path.start_vertex_ = findStartLocationWithZ(path, path.seam_config_.pos_, 0);
            }
        }
    }
    
    // 6. 路径顺序优化
    std::vector<OrderablePath> optimized_order;
    if (order_requirements_->empty()) {
        optimized_order = getOptimizedOrder(line_bucket_grid, snap_radius);
    } else {
        optimized_order = getOptimizerOrderWithConstraints(*order_requirements_);
    }
    
    // 7. 方向处理
    if (reverse_direction_ && order_requirements_->empty()) {
        std::vector<OrderablePath> reversed = reverseOrderPaths(optimized_order);
        std::swap(reversed, paths_);
    } else {
        std::swap(optimized_order, paths_);
    }
}
```

### 2. 贪心优化算法 (getOptimizedOrder)

这是无约束条件下的核心优化算法，采用贪心策略：

```cpp
std::vector<OrderablePath> getOptimizedOrder(SparsePointGridInclusive<size_t> line_bucket_grid, size_t snap_radius)
{
    Point2LL current_position = start_point_;
    std::unordered_map<OrderablePath*, bool> picked(paths_.size());
    
    while (optimized_order.size() < paths_.size()) {
        // 1. 使用空间网格查找附近候选路径
        std::vector<OrderablePath*> nearby_candidates;
        for (const auto i : line_bucket_grid.getNearbyVals(current_position, snap_radius)) {
            nearby_candidates.push_back(&paths_[i]);
        }
        
        // 2. 过滤未选择的候选路径
        std::vector<OrderablePath*> available_candidates;
        for (auto candidate : nearby_candidates | ranges::views::filter(notPicked)) {
            available_candidates.push_back(candidate);
        }
        
        // 3. 如果附近没有候选路径，扩展到全部路径
        if (available_candidates.empty()) {
            for (auto path : paths_ | ranges::views::addressof | ranges::views::filter(notPicked)) {
                available_candidates.push_back(path);
            }
        }
        
        // 4. 选择最近的路径
        auto best_candidate = findClosestPath(current_position, available_candidates);
        optimized_order.push_back(*best_candidate);
        picked[best_candidate] = true;
        
        // 5. 更新当前位置
        if (best_candidate->is_closed_) {
            current_position = (*best_candidate->converted_)[best_candidate->start_vertex_];
        } else {
            current_position = best_candidate->start_vertex_ == 0 ? 
                best_candidate->converted_->back() : best_candidate->converted_->front();
        }
    }
    
    return optimized_order;
}
```

### 3. 约束优化算法 (getOptimizerOrderWithConstraints)

处理有顺序约束的路径优化，使用拓扑排序和深度优先搜索：

```cpp
std::vector<OrderablePath> getOptimizerOrderWithConstraints(const std::unordered_multimap<Path, Path>& order_requirements)
{
    // 1. 构建依赖图
    std::unordered_set<Path> roots, leaves;
    std::unordered_map<Path, size_t> num_incoming_edges;
    
    // 2. 识别根节点和叶节点
    for (const auto& [u, v] : order_requirements) {
        roots.erase(v);
        leaves.erase(u);
        num_incoming_edges.find(v)->second++;
    }
    
    // 3. 定义邻居获取函数
    std::function<std::vector<Path>(const Path, const std::unordered_multimap<Path, Path>&)> get_neighbours = 
        [&](const Path current_node, const std::unordered_multimap<Path, Path>& graph) {
            // 只访问没有入边的节点，确保依赖关系正确
            std::unordered_set<Path> candidates;
            for (const auto& [_, neighbour] : graph.equal_range(current_node)) {
                if (num_incoming_edges.at(neighbour) == 0) {
                    candidates.insert(neighbour);
                }
            }
            
            // 按距离排序候选节点
            std::vector<Path> order;
            while (!candidates.empty()) {
                Path best_candidate = findClosestPathVertices(local_current_position, candidates);
                candidates.erase(best_candidate);
                order.push_back(best_candidate);
                // 更新位置...
            }
            return order;
        };
    
    // 4. 处理外壁分组
    if (_group_outer_walls) {
        // 根据reverse_direction_决定处理顺序
        if (reverse_direction_) {
            // 先处理内壁，后处理外壁
        } else {
            // 先处理外壁，后处理内壁
        }
    }
    
    // 5. 深度优先搜索遍历
    while (!roots.empty()) {
        Path root = findClosestPathVertices(current_position, roots);
        roots.erase(root);
        actions::dfs(root, order_requirements, handle_node, visited, nullptr, get_neighbours);
    }
    
    return optimized_order;
}
```

## Z缝合位置优化

### 1. 缝合点查找算法 (findStartLocationWithZ)

这是一个复杂的多标准评分系统：

```cpp
size_t findStartLocationWithZ(const OrderablePath& path, const Point2LL& target_pos, coord_t layer_z)
{
    if (!path.is_closed_) {
        // 开放路径：选择距离目标点最近的端点
        const coord_t back_distance = (combing_boundary_ == nullptr) ? 
            getDirectDistance(path.converted_->back(), target_pos) : 
            getCombingDistance(path.converted_->back(), target_pos);
        
        if (back_distance < getDirectDistance(path.converted_->front(), target_pos)) {
            return path.converted_->size() - 1;
        }
        return 0;
    }
    
    // 闭合路径：使用多标准评分系统
    BestElementFinder best_candidate_finder;
    BestElementFinder::CriteriaPass main_criteria_pass;
    main_criteria_pass.outsider_delta_threshold = 0.05;
    
    // 主要评分标准
    BestElementFinder::WeighedCriterion main_criterion;
    
    // 自定义Z缝合点处理
    if (path.seam_config_.draw_z_seam_enable_) {
        auto interpolated_pos = path.seam_config_.getInterpolatedSeamPosition();
        if (interpolated_pos.has_value()) {
            Point2LL custom_target_pos = interpolated_pos.value();
            main_criterion.criterion = std::make_shared<DistanceScoringCriterion>(points, custom_target_pos);
        }
    }
    // 强制起始点
    else if (path.force_start_index_.has_value()) {
        main_criterion.criterion = std::make_shared<DistanceScoringCriterion>(
            points, points.at(path.force_start_index_.value()), 
            DistanceScoringCriterion::DistanceType::Euclidian, 1.0);
    }
    // 最短距离或用户指定
    else if (path.seam_config_.type_ == EZSeamType::SHORTEST || 
             path.seam_config_.type_ == EZSeamType::USER_SPECIFIED) {
        main_criterion.criterion = std::make_shared<DistanceScoringCriterion>(points, target_pos);
    }
    // 最尖锐角
    else if (path.seam_config_.type_ == EZSeamType::SHARPEST_CORNER) {
        main_criterion.criterion = std::make_shared<CornerScoringCriterion>(points, path.seam_config_.corner_pref_);
    }
    // 随机
    else if (path.seam_config_.type_ == EZSeamType::RANDOM) {
        main_criterion.criterion = std::make_shared<RandomScoringCriterion>();
    }
    
    // 添加回退策略
    if (path.seam_config_.type_ == EZSeamType::SHARPEST_CORNER) {
        // 回退策略1：选择最后方的点
        auto fallback_criterion = std::make_shared<DistanceScoringCriterion>(
            points, path_bounding_box.max_, DistanceScoringCriterion::DistanceType::YOnly);
        best_candidate_finder.appendSingleCriterionPass(fallback_criterion, 0.01);
        
        // 回退策略2：选择最右方的点
        auto fallback_criterion2 = std::make_shared<DistanceScoringCriterion>(
            points, path_bounding_box.max_, DistanceScoringCriterion::DistanceType::XOnly);
        best_candidate_finder.appendSingleCriterionPass(fallback_criterion2);
    }
    
    // 应用评分标准
    std::optional<size_t> best_i = best_candidate_finder.findBestElement(points.size());
    
    // 检查禁止区域
    if (!disallowed_area_for_seams.empty()) {
        best_i = pathIfZseamIsInDisallowedArea(best_i.value_or(0), path, 0);
    }
    
    return best_i.value_or(0);
}
```

### 2. 评分标准系统

系统使用多种评分标准：

1. **DistanceScoringCriterion**: 基于距离的评分
2. **CornerScoringCriterion**: 基于角度的评分
3. **RandomScoringCriterion**: 随机评分
4. **ExclusionAreaScoringCriterion**: 排除区域评分

## 避障路径计算

### 1. 直线距离计算

```cpp
coord_t getDirectDistance(const Point2LL& a, const Point2LL& b) const
{
    return vSize2(a - b);  // 返回距离的平方
}
```

### 2. 避障距离计算

```cpp
coord_t getCombingDistance(const Point2LL& a, const Point2LL& b)
{
    // 1. 检查是否与边界碰撞
    if (!PolygonUtils::polygonCollidesWithLineSegment(*combing_boundary_, a, b)) {
        return getDirectDistance(a, b);
    }
    
    // 2. 路径数量过多时使用静态惩罚因子
    if (paths_.size() > 100) {
        return getDirectDistance(a, b) * 5;
    }
    
    // 3. 构建避障网格
    if (combing_grid_ == nullptr) {
        constexpr coord_t grid_size = 2000;
        combing_grid_ = PolygonUtils::createLocToLineGrid(*combing_boundary_, grid_size);
    }
    
    // 4. 计算避障路径
    CombPath comb_path;
    constexpr coord_t rounding_error = -25;
    constexpr coord_t tiny_travel_threshold = 0;
    constexpr bool fail_on_unavoidable_obstacles = false;
    
    LinePolygonsCrossings::comb(*combing_boundary_, *combing_grid_, a, b, comb_path, 
                               rounding_error, tiny_travel_threshold, fail_on_unavoidable_obstacles);
    
    // 5. 计算总距离
    coord_t sum = 0;
    Point2LL last_point = a;
    for (const Point2LL& point : comb_path) {
        sum += vSize(point - last_point);
        last_point = point;
    }
    return sum * sum;  // 平方距离，便于比较
}
```

## 优化目标和策略

### 1. 主要优化目标

1. **最小化移动距离**: 减少喷嘴在不同打印元素间的移动时间
2. **优化缝合位置**: 将Z缝合放在不显眼或结构上合适的位置
3. **避免碰撞**: 在移动时避开已打印的结构
4. **满足约束**: 遵守打印顺序要求（如外壁优先）

### 2. 优化策略

1. **空间分区**: 使用网格加速邻近查找
2. **贪心选择**: 每步选择当前最优的下一个路径
3. **多标准评分**: 综合考虑距离、角度、随机性等因素
4. **约束满足**: 使用拓扑排序处理依赖关系

### 3. 可控参数

1. **seam_config**: Z缝合配置
2. **detect_loops**: 是否检测闭合回路
3. **reverse_direction**: 是否反向打印
4. **group_outer_walls**: 是否分组外壁
5. **use_shortest_for_inner_walls**: 内壁是否使用最短路径
6. **combing_boundary**: 避障边界
7. **order_requirements**: 顺序约束
8. **disallowed_area_for_seams**: 禁止缝合区域
9. **overhang_areas**: 悬垂区域

## 性能优化

### 1. 空间索引

使用 `SparsePointGridInclusive` 进行空间分区，将O(n²)的距离计算优化为O(n)。

### 2. 预计算

对于某些缝合类型（RANDOM、USER_SPECIFIED、SHARPEST_CORNER），预先计算起始位置。

### 3. 避障优化

- 路径数量超过100时使用静态惩罚因子
- 缓存避障网格避免重复计算
- 使用平方距离避免开方运算

### 4. 内存管理

- 使用智能指针管理避障网格
- 复用数据结构减少内存分配
- 使用引用和指针避免不必要的拷贝

## 应用场景

### 1. 不同打印类型的优化

- **外壁 (Outer Walls)**: 重点优化缝合位置和表面质量
- **内壁 (Inner Walls)**: 优先考虑打印效率
- **填充 (Infill)**: 最小化移动距离
- **表面 (Skin)**: 平衡质量和效率
- **支撑 (Support)**: 优化移除便利性

### 2. 特殊处理

- **悬垂区域**: 避免在悬垂处开始打印
- **桥接**: 优化桥接方向和起始点
- **薄壁**: 特殊的缝合策略
- **小特征**: 减速和特殊路径规划

## 评分标准系统详解

### 1. BestElementFinder 类

**文件位置**: `CuraEngine/include/utils/scoring/BestElementFinder.h`

这是一个通用的多标准评分框架：

```cpp
class BestElementFinder
{
public:
    struct WeighedCriterion
    {
        std::shared_ptr<ScoringCriterion> criterion;  // 评分标准
        double weight = 1.0;                          // 权重
    };

    struct CriteriaPass
    {
        std::vector<WeighedCriterion> criteria;       // 评分标准列表
        double outsider_delta_threshold = 0.0;       // 异常值阈值
    };

    void appendCriteriaPass(const CriteriaPass& pass);
    void appendSingleCriterionPass(std::shared_ptr<ScoringCriterion> criterion,
                                  double outsider_delta_threshold = 0.0);
    std::optional<size_t> findBestElement(size_t element_count);
};
```

### 2. 具体评分标准

#### DistanceScoringCriterion（距离评分）

```cpp
class DistanceScoringCriterion : public ScoringCriterion
{
public:
    enum class DistanceType
    {
        Euclidian,    // 欧几里得距离
        XOnly,        // 仅X方向距离
        YOnly,        // 仅Y方向距离
    };

    DistanceScoringCriterion(const PointsSet& points,
                           const Point2LL& target_point,
                           DistanceType distance_type = DistanceType::Euclidian,
                           double distance_divider = 1000.0);

    double computeScore(size_t candidate_index) const override;
};
```

#### CornerScoringCriterion（角度评分）

```cpp
class CornerScoringCriterion : public ScoringCriterion
{
public:
    CornerScoringCriterion(const PointsSet& points,
                          EZSeamCornerPrefType corner_preference);

    double computeScore(size_t candidate_index) const override;

private:
    double calculateCornerAngle(size_t index) const;
    double getCornerScore(double angle) const;
};
```

#### RandomScoringCriterion（随机评分）

```cpp
class RandomScoringCriterion : public ScoringCriterion
{
public:
    RandomScoringCriterion(uint32_t seed = 0);
    double computeScore(size_t candidate_index) const override;

private:
    mutable std::mt19937 random_generator_;
};
```

## 高级优化技术

### 1. 自定义Z缝合点系统

**实现位置**: `PathOrderOptimizer::findStartLocationWithZ` 函数

```cpp
// 自定义Z缝合点处理逻辑
if (path.seam_config_.draw_z_seam_enable_) {
    spdlog::info("=== 外轮廓自定义Z接缝点处理开始 ===");

    // 尝试获取当前层的插值接缝位置
    auto interpolated_pos = path.seam_config_.getInterpolatedSeamPosition();
    if (interpolated_pos.has_value()) {
        Point2LL custom_target_pos = interpolated_pos.value();

        // 创建距离评分标准，优先选择最接近自定义位置的顶点
        main_criterion.criterion = std::make_shared<DistanceScoringCriterion>(
            points, custom_target_pos);

        spdlog::info("使用自定义接缝位置: ({:.2f}, {:.2f})",
                   INT2MM(custom_target_pos.X), INT2MM(custom_target_pos.Y));
    } else {
        // 插值失败，回退到默认处理方式
        spdlog::info("插值失败，使用默认处理方式");
        main_criterion.criterion = std::make_shared<DistanceScoringCriterion>(
            points, target_pos);
    }
}
```

### 2. 禁止区域处理

```cpp
size_t pathIfZseamIsInDisallowedArea(size_t best_pos, const OrderablePath& path,
                                   size_t number_of_paths_analysed)
{
    size_t path_size = path.converted_->size();
    if (path_size > number_of_paths_analysed) {
        if (!disallowed_area_for_seams.empty()) {
            Point2LL current_candidate = (path.converted_)->at(best_pos);
            if (disallowed_area_for_seams.inside(current_candidate, true)) {
                // 当前位置在禁止区域内，寻找下一个位置
                size_t next_best_position = (path_size > best_pos + 1) ? best_pos + 1 : 0;
                number_of_paths_analysed += 1;
                best_pos = pathIfZseamIsInDisallowedArea(next_best_position, path,
                                                       number_of_paths_analysed);
            }
        }
    } else {
        spdlog::warn("No start path found for support z seam distance");
        // 所有位置都在禁止区域内，可能需要计算最佳妥协位置
    }
    return best_pos;
}
```

### 3. 闭合回路检测

```cpp
bool isLoopingPolyline(const OrderablePath& path)
{
    if (path.converted_->empty()) {
        return false;
    }

    // 检查首尾点距离是否小于重合阈值
    coord_t distance_squared = vSize2(path.converted_->back() - path.converted_->front());
    return distance_squared < _coincident_point_distance * _coincident_point_distance;
}
```

### 4. 方向反转处理

```cpp
std::vector<OrderablePath> reverseOrderPaths(std::vector<OrderablePath> pathsOrderPaths)
{
    std::vector<OrderablePath> reversed;
    reversed.reserve(pathsOrderPaths.size());

    for (auto& path : pathsOrderPaths | ranges::views::reverse) {
        reversed.push_back(path);
        reversed.back().backwards_ = !reversed.back().backwards_;

        if (!reversed.back().is_closed_) {
            // 对于开放路径，调整起始顶点
            reversed.back().start_vertex_ =
                reversed.back().converted_->size() - 1 - reversed.back().start_vertex_;
        }
    }

    return reversed;
}
```

## 实际应用案例

### 1. 外壁优化案例

```cpp
// 外壁路径优化配置
PathOrderOptimizer<ConstPolygonRef> wall_optimizer(
    start_point,
    ZSeamConfig(EZSeamType::SHARPEST_CORNER, Point2LL(0, 0),
               EZSeamCornerPrefType::Z_SEAM_CORNER_PREF_INNER),
    false,  // detect_loops
    &comb_boundary,
    false,  // reverse_direction
    no_order_requirements,
    true,   // group_outer_walls
    disallowed_areas,
    false,  // use_shortest_for_inner_walls
    overhang_areas
);

// 添加外壁路径
for (const auto& wall : outer_walls) {
    wall_optimizer.addPolygon(wall, std::nullopt, true);  // is_outer_wall = true
}

wall_optimizer.optimize();
```

### 2. 填充路径优化案例

```cpp
// 填充路径优化配置
PathOrderOptimizer<ConstPolygonRef> infill_optimizer(
    start_point,
    ZSeamConfig(EZSeamType::SHORTEST),  // 填充使用最短距离
    true,   // detect_loops
    nullptr, // 填充通常不需要避障
    false,  // reverse_direction
    no_order_requirements,
    false,  // group_outer_walls
    Shape(), // 填充不考虑禁止区域
    false,  // use_shortest_for_inner_walls
    Shape()  // 填充不考虑悬垂区域
);

// 添加填充线段
for (const auto& line : infill_lines) {
    infill_optimizer.addPolyline(line);
}

infill_optimizer.optimize();
```

### 3. 支撑路径优化案例

```cpp
// 支撑路径优化配置
PathOrderOptimizer<ConstPolygonRef> support_optimizer(
    start_point,
    ZSeamConfig(EZSeamType::RANDOM),  // 支撑使用随机缝合
    false,  // detect_loops
    &model_boundary,  // 避开模型
    false,  // reverse_direction
    no_order_requirements,
    false,  // group_outer_walls
    model_areas,  // 避免在模型上开始
    false,  // use_shortest_for_inner_walls
    Shape()   // 支撑不考虑悬垂区域
);

// 添加支撑路径
for (const auto& support_part : support_parts) {
    support_optimizer.addPolygon(support_part);
}

support_optimizer.optimize();
```

## 调试和性能分析

### 1. 性能监控

```cpp
void PathOrderOptimizer::optimize(bool precompute_start)
{
    auto start_time = std::chrono::high_resolution_clock::now();

    // 执行优化算法...

    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);

    spdlog::debug("Path optimization took {} ms for {} paths",
                 duration.count(), paths_.size());
}
```

### 2. 路径质量评估

```cpp
double evaluatePathQuality(const std::vector<OrderablePath>& paths)
{
    double total_distance = 0.0;
    Point2LL current_pos = start_point_;

    for (const auto& path : paths) {
        if (!path.converted_->empty()) {
            Point2LL path_start = (*path.converted_)[path.start_vertex_];
            total_distance += vSize(current_pos - path_start);

            if (path.is_closed_) {
                current_pos = path_start;  // 闭合路径回到起点
            } else {
                current_pos = path.start_vertex_ == 0 ?
                    path.converted_->back() : path.converted_->front();
            }
        }
    }

    return total_distance;
}
```

### 3. 缝合质量分析

```cpp
void analyzeSeamQuality(const std::vector<OrderablePath>& paths)
{
    std::map<EZSeamType, int> seam_type_count;
    std::vector<double> seam_distances;

    for (const auto& path : paths) {
        seam_type_count[path.seam_config_.type_]++;

        if (path.is_closed_ && !path.converted_->empty()) {
            Point2LL seam_pos = (*path.converted_)[path.start_vertex_];
            // 分析缝合位置质量...
        }
    }

    spdlog::info("Seam analysis: SHORTEST={}, SHARPEST_CORNER={}, RANDOM={}",
                seam_type_count[EZSeamType::SHORTEST],
                seam_type_count[EZSeamType::SHARPEST_CORNER],
                seam_type_count[EZSeamType::RANDOM]);
}
```

这个路径优化系统是 CuraEngine 的核心组件之一，它通过复杂的算法和多种优化策略，确保打印路径的高效性和打印质量的优化。通过深入理解这些算法和参数，开发者可以针对特定需求进行定制化优化。
