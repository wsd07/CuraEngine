# 崩溃安全调试使用指南

## 🎯 **目标**

解决原始assert在程序崩溃时来不及输出错误信息的问题，提供详细的崩溃诊断信息，帮助快速定位和修复问题。

## 🔧 **新的错误处理工具**

### **1. 立即刷新的错误日志**
```cpp
// 替代原来的CURA_ERROR，确保信息立即输出
CURA_ERROR_FLUSH("详细的错误描述");
CURA_ERROR_FLUSH_F("格式化错误: %d, %s", value, description);
```

### **2. 带断言的错误检查**
```cpp
// 输出详细信息后再触发断言，确保调试信息不丢失
CURA_ASSERT_WITH_INFO(condition, "详细的错误描述和上下文信息");
```

### **3. 条件错误检查**
```cpp
// 检查条件，失败时输出错误但不崩溃
if (!CURA_CHECK_WITH_ERROR(condition, "错误描述")) {
    // 处理错误情况
    return false;
}
```

## 📋 **使用策略对比**

### **原始方法 (问题)**
```cpp
assert(source_twin);  // 崩溃时可能来不及输出任何信息
```

### **方法1: 纯错误日志 (之前的重构)**
```cpp
if (!source_twin) {
    CURA_ERROR("source_twin为空");  // 可能来不及输出
    return;  // 程序继续运行，可能后续崩溃
}
```

### **方法2: 崩溃安全断言 (推荐)**
```cpp
CURA_ASSERT_WITH_INFO(source_twin, 
    "source_twin为空，vd_edge映射失败，可能原因：Voronoi图构建不完整");
// 确保错误信息输出后再崩溃，便于调试
```

### **方法3: 条件检查 (生产环境)**
```cpp
if (!CURA_CHECK_WITH_ERROR(source_twin, "source_twin为空，跳过此边缘")) {
    continue;  // 优雅处理，程序继续运行
}
```

## 🚀 **实际应用示例**

### **示例1: 指针验证**
```cpp
// 原始代码
edge_t* source_twin = he_edge_it->second;
assert(source_twin);

// 崩溃安全版本
edge_t* source_twin = he_edge_it->second;
CURA_ASSERT_WITH_INFO(source_twin, 
    "Voronoi边缘映射失败: vd_edge地址=%p, twin地址=%p, 映射表大小=%zu",
    &vd_edge, vd_edge.twin(), vd_edge_to_he_edge_.size());
```

### **示例2: 数值范围验证**
```cpp
// 原始代码
assert(start_pos <= ab_size);

// 崩溃安全版本
CURA_ASSERT_WITH_INFO(start_pos <= ab_size,
    "位置超出边缘范围: start_pos=%d, ab_size=%d, edge=(%d,%d)->(%d,%d)",
    start_pos, ab_size, a.X, a.Y, b.X, b.Y);
```

### **示例3: 条件逻辑验证**
```cpp
// 原始代码
assert(edge.from_->data_.bead_count_ == edge.to_->data_.bead_count_ || 
       edge.data_.hasTransitions());

// 崩溃安全版本
CURA_ASSERT_WITH_INFO(
    edge.from_->data_.bead_count_ == edge.to_->data_.bead_count_ || edge.data_.hasTransitions(),
    "边缘bead计数不一致且无过渡: from_count=%d, to_count=%d, hasTransitions=%s",
    edge.from_->data_.bead_count_, edge.to_->data_.bead_count_, 
    edge.data_.hasTransitions() ? "true" : "false");
```

## 🔍 **调试工作流程**

### **1. 初始化崩溃处理器**
```cpp
// 在main函数或适当位置调用
cura::CrashSafeDebug::initialize();
```

### **2. 运行程序**
- 程序遇到问题时会输出详细的错误信息
- 信息会同时输出到日志和终端
- 程序崩溃时会显示调用栈

### **3. 分析输出**
```
[ERROR] ASSERTION FAILED: source_twin
[ERROR] Voronoi边缘映射失败: vd_edge地址=0x7fff123, twin地址=0x7fff456, 映射表大小=1024
[ERROR] 程序将在此处停止以便调试

=== 程序崩溃 ===
信号: SIGABRT (断言失败) (6)

=== 调用栈 ===
  [0] SkeletalTrapezoidation::transferEdge(...)
  [1] SkeletalTrapezoidation::constructFromPolygons(...)
  [2] main(...)

=== 调试建议 ===
1. 查看上面的错误日志了解崩溃原因
2. 使用调试器 (gdb/lldb) 获取更详细信息
3. 检查最近的CURA_ERROR_FLUSH输出
```

## 📊 **选择合适的策略**

### **调试阶段**
- 使用 `CURA_ASSERT_WITH_INFO` 确保获得完整的错误信息
- 程序崩溃但提供详细的诊断信息

### **测试阶段**
- 使用 `CURA_CHECK_WITH_ERROR` 进行优雅的错误处理
- 程序继续运行，记录所有问题

### **生产阶段**
- 根据错误的严重性选择合适的处理方式
- 关键错误使用断言，一般错误使用检查

## 🎉 **优势**

1. **信息不丢失**: 错误信息在程序崩溃前就已输出
2. **详细诊断**: 提供丰富的上下文信息
3. **调用栈**: 自动显示崩溃时的调用栈
4. **灵活选择**: 可以选择崩溃或继续运行
5. **调试友好**: 与调试器完美配合

这个系统让您能够在程序崩溃时获得完整的诊断信息，大大提高调试效率！
