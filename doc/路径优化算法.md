# 路径优化算法

## 概述

CuraEngine 的路径优化系统通过 `PathOrderOptimizer` 类实现，核心目标是优化打印路径的顺序，最小化喷嘴移动距离，同时考虑 Z 缝合位置、避障路径规划等因素。

## 核心类结构

### PathOrderOptimizer<Path> 模板类

**文件位置**: `CuraEngine/include/PathOrderOptimizer.h`

#### 主要成员变量

```cpp
class PathOrderOptimizer
{
    std::vector<OrderablePath> paths_;                    // 优化后的路径列表
    std::unordered_map<Path, OrderablePath*> vertices_to_paths_; // 路径映射
    Point2LL start_point_;                               // 起始位置
    ZSeamConfig seam_config_;                           // Z缝合配置
    Shape disallowed_area_for_seams;                    // 禁止缝合的区域
    const Shape* combing_boundary_;                     // 避障边界
    bool detect_loops_;                                 // 是否检测闭合回路
    bool reverse_direction_;                            // 是否反向打印
    bool _group_outer_walls;                           // 是否分组外壁
    const std::unordered_multimap<Path, Path>* order_requirements_; // 顺序约束
    bool use_shortest_for_inner_walls_;                // 内壁是否使用最短路径
    Shape overhang_areas_;                             // 悬垂区域
};
```

#### 关键算法参数

1. **snap_radius**: 10微米，用于邻近点检测的网格大小
2. **_coincident_point_distance**: 10微米，判断端点重合的距离阈值
3. **grid_size**: 2000微米（2mm），避障网格大小
4. **max_distance_ignored**: 喷嘴直径，忽略短距离移动的阈值

### PathOrdering<PathType> 结构

**文件位置**: `CuraEngine/include/path_ordering.h`

```cpp
struct PathOrdering
{
    PathType vertices_;                    // 原始顶点数据
    const PointsSet* converted_;          // 转换后的多边形数据
    size_t start_vertex_;                 // 起始顶点索引
    bool is_closed_;                      // 是否闭合路径
    bool backwards_;                      // 是否反向打印
    std::optional<size_t> force_start_index_; // 强制起始点
    ZSeamConfig seam_config_;            // 缝合配置
    bool is_outer_wall;                  // 是否外壁
};
```

## 优化算法详解

### 1. 主优化流程 (optimize函数)

```cpp
void optimize(bool precompute_start = true)
{
    // 1. 数据预处理
    for (auto& path : paths_) {
        path.converted_ = &path.getVertexData();
        vertices_to_paths_.emplace(path.vertices_, &path);
    }
    
    // 2. 闭合回路检测
    if (detect_loops_) {
        for (auto& path : paths_) {
            if (!path.is_closed_) {
                path.is_closed_ = isLoopingPolyline(path);
            }
        }
    }
    
    // 3. 缝合策略设置
    for (auto& path : paths_) {
        if (use_shortest_for_inner_walls_ && !path.is_outer_wall) {
            path.seam_config_ = ZSeamConfig(EZSeamType::SHORTEST);
        }
    }
    
    // 4. 空间索引构建
    SparsePointGridInclusive<size_t> line_bucket_grid(snap_radius);
    
    // 5. 缝合点预计算
    if (precompute_start) {
        for (auto& path : paths_) {
            if (path.seam_config_.type_ == EZSeamType::RANDOM || 
                path.seam_config_.type_ == EZSeamType::USER_SPECIFIED ||
                path.seam_config_.type_ == EZSeamType::SHARPEST_CORNER) {
                path.start_vertex_ = findStartLocationWithZ(path, path.seam_config_.pos_, 0);
            }
        }
    }
    
    // 6. 路径顺序优化
    std::vector<OrderablePath> optimized_order;
    if (order_requirements_->empty()) {
        optimized_order = getOptimizedOrder(line_bucket_grid, snap_radius);
    } else {
        optimized_order = getOptimizerOrderWithConstraints(*order_requirements_);
    }
    
    // 7. 方向处理
    if (reverse_direction_ && order_requirements_->empty()) {
        std::vector<OrderablePath> reversed = reverseOrderPaths(optimized_order);
        std::swap(reversed, paths_);
    } else {
        std::swap(optimized_order, paths_);
    }
}
```

### 2. 贪心优化算法 (getOptimizedOrder)

采用贪心策略的核心优化算法：

```cpp
std::vector<OrderablePath> getOptimizedOrder(SparsePointGridInclusive<size_t> line_bucket_grid, size_t snap_radius)
{
    Point2LL current_position = start_point_;
    std::unordered_map<OrderablePath*, bool> picked(paths_.size());
    
    while (optimized_order.size() < paths_.size()) {
        // 1. 使用空间网格查找附近候选路径
        std::vector<OrderablePath*> nearby_candidates;
        for (const auto i : line_bucket_grid.getNearbyVals(current_position, snap_radius)) {
            nearby_candidates.push_back(&paths_[i]);
        }
        
        // 2. 过滤未选择的候选路径
        std::vector<OrderablePath*> available_candidates;
        for (auto candidate : nearby_candidates | ranges::views::filter(notPicked)) {
            available_candidates.push_back(candidate);
        }
        
        // 3. 如果附近没有候选路径，扩展到全部路径
        if (available_candidates.empty()) {
            for (auto path : paths_ | ranges::views::addressof | ranges::views::filter(notPicked)) {
                available_candidates.push_back(path);
            }
        }
        
        // 4. 选择最近的路径
        auto best_candidate = findClosestPath(current_position, available_candidates);
        optimized_order.push_back(*best_candidate);
        picked[best_candidate] = true;
        
        // 5. 更新当前位置
        if (best_candidate->is_closed_) {
            current_position = (*best_candidate->converted_)[best_candidate->start_vertex_];
        } else {
            current_position = best_candidate->start_vertex_ == 0 ? 
                best_candidate->converted_->back() : best_candidate->converted_->front();
        }
    }
    
    return optimized_order;
}
```

### 3. 约束优化算法 (getOptimizerOrderWithConstraints)

处理有顺序约束的路径优化，使用拓扑排序和深度优先搜索：

```cpp
std::vector<OrderablePath> getOptimizerOrderWithConstraints(const std::unordered_multimap<Path, Path>& order_requirements)
{
    // 1. 构建依赖图
    std::unordered_set<Path> roots, leaves;
    std::unordered_map<Path, size_t> num_incoming_edges;
    
    // 2. 识别根节点和叶节点
    for (const auto& [u, v] : order_requirements) {
        roots.erase(v);
        leaves.erase(u);
        num_incoming_edges.find(v)->second++;
    }
    
    // 3. 定义邻居获取函数
    std::function<std::vector<Path>(const Path, const std::unordered_multimap<Path, Path>&)> get_neighbours = 
        [&](const Path current_node, const std::unordered_multimap<Path, Path>& graph) {
            // 只访问没有入边的节点，确保依赖关系正确
            std::unordered_set<Path> candidates;
            for (const auto& [_, neighbour] : graph.equal_range(current_node)) {
                if (num_incoming_edges.at(neighbour) == 0) {
                    candidates.insert(neighbour);
                }
            }
            
            // 按距离排序候选节点
            std::vector<Path> order;
            while (!candidates.empty()) {
                Path best_candidate = findClosestPathVertices(local_current_position, candidates);
                candidates.erase(best_candidate);
                order.push_back(best_candidate);
                // 更新位置...
            }
            return order;
        };
    
    // 4. 处理外壁分组
    if (_group_outer_walls) {
        // 根据reverse_direction_决定处理顺序
        if (reverse_direction_) {
            // 先处理内壁，后处理外壁
        } else {
            // 先处理外壁，后处理内壁
        }
    }
    
    // 5. 深度优先搜索遍历
    while (!roots.empty()) {
        Path root = findClosestPathVertices(current_position, roots);
        roots.erase(root);
        actions::dfs(root, order_requirements, handle_node, visited, nullptr, get_neighbours);
    }
    
    return optimized_order;
}
```

## 优化目标和策略

### 主要优化目标

1. **最小化移动距离**: 减少喷嘴在不同打印元素间的移动时间
2. **优化缝合位置**: 将Z缝合放在不显眼或结构上合适的位置
3. **避免碰撞**: 在移动时避开已打印的结构
4. **满足约束**: 遵守打印顺序要求（如外壁优先）

### 优化策略

1. **空间分区**: 使用网格加速邻近查找
2. **贪心选择**: 每步选择当前最优的下一个路径
3. **多标准评分**: 综合考虑距离、角度、随机性等因素
4. **约束满足**: 使用拓扑排序处理依赖关系

### 可控参数

1. **seam_config**: Z缝合配置
2. **detect_loops**: 是否检测闭合回路
3. **reverse_direction**: 是否反向打印
4. **group_outer_walls**: 是否分组外壁
5. **use_shortest_for_inner_walls**: 内壁是否使用最短路径
6. **combing_boundary**: 避障边界
7. **order_requirements**: 顺序约束
8. **disallowed_area_for_seams**: 禁止缝合区域
9. **overhang_areas**: 悬垂区域

## 性能优化

### 空间索引

使用 `SparsePointGridInclusive` 进行空间分区，将O(n²)的距离计算优化为O(n)。

### 预计算

对于某些缝合类型（RANDOM、USER_SPECIFIED、SHARPEST_CORNER），预先计算起始位置。

### 避障优化

- 路径数量超过100时使用静态惩罚因子
- 缓存避障网格避免重复计算
- 使用平方距离避免开方运算

### 内存管理

- 使用智能指针管理避障网格
- 复用数据结构减少内存分配
- 使用引用和指针避免不必要的拷贝
